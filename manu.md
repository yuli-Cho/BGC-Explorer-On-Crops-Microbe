## Getting Started
### Prerequisites
Before running the pipeline, ensure you have the following installed:  


### Software that needs to be installed in the shell  
**deepbgc**  
**eggNOG**  
**Python 3.6**  
**fastp** (for quality control)  
**hisat2** (for alignment)  
**samtools** (for BAM file processing)  
**featureCounts** (for gene counting)  
**eggNOG-mapper** (for functional annotation)  
**seqkit** (for sequence manipulation)  

**##Usage**
## In shell
1. Please download the eggNOG database before you start and save it in the data folder under the eggnog-mapper software directory.\

```
wget http://eggnog5.embl.de/download/emapperdb-5.0.2/eggnog.db.gz
wget http://eggnog5.embl.de/download/emapperdb-5.0.2/eggnog.taxa.tar.gz
wget http://eggnog5.embl.de/download/emapperdb-5.0.2/eggnog_proteins.dmnd.gz
wget http://eggnog5.embl.de/download/emapperdb-5.0.2/mmseqs.tar.gz
wget http://eggnog5.embl.de/download/emapperdb-5.0.2/pfam.tar.gz
```

2. Please download genome.fa file and species transcriptome data first  



**1.Running emapper.py**  
performs the gene annotation and mapping task, with results stored in the specified output directory. Log output is redirected to a log file for tracking the process.  
```
nohup emapper.py --cpu 48  --data_dir /your/path/of/eggnog-mapper-software/    --decorate_gff yes   --tax_scope eukaryota   --itype genome  -m mmseqs  -i /your/path/of/fasta/all.chrs.fasta --override  --output_dir /your/output/dir/output_name   -o eggnog > ./your/output/log_files/output_name.log  2>&1  &
```


**2.Clean Annotation File**   
removes lines starting with ## from the annotation file, which are typically comments. It then removes the # character from the remaining lines, creating a cleaned annotation file (eggnog.anno) for further use.  
```
sed '/^##/d' "/your/output/dir/output_name/eggnog.emapper.annotations" |sed 's/#//' > "/your/output/dir/output_name/eggnog.anno"
```


**3.Extract Specific Fields from GFF File**  
extracts lines containing ID from the GFF file, processes the relevant fields to remove unnecessary characters, and formats the output into a tab-separated file (eggnog.emapper.decorated.gff.saf) with specific columns.  
```
grep 'ID' "/your/output/dir/output_name/eggnog.emapper.decorated.gff" | cut -d ';' -f1 | tr -d ' ' | sed 's/ID=//g' | awk -v OFS='\t' '{print $9,$1,$4,$5,$7}' > "/your/output/dir/output_name/eggnog.emapper.decorated.gff.saf"
```


 **4.Extract Gene IDs from Fasta File**  
extracts gene identifiers from the eggnog.emapper.genepred.fasta file by converting it to a tab-delimited format, stripping the ID= prefix, and saving the processed gene IDs into a separate file (geneid_match.tab).  
```
seqkit fx2tab -n  "/your/output/dir/output_name/eggnog.emapper.genepred.fasta" | awk '{print $1,$9}' | awk -F';' '{print $1}' | sed 's/ID=//g' > "/your/output/dir/output_name/geneid_match.tab"
```


**5.run RNAseq analysis**  
Please download and save the egg_rice_rnaseq_part.sh script for RNAseq analysis.  
**Input**    
**$1:** Directory containing sample fastq files (paired-end fastq.gz files).  
**$2:** Directory where output files will be stored.  
**$3:** Reference genome in .fna format (FASTA format).  
**$4:** Directory containing eggNOG reference files.  


**Output**    
**$2/anno/:** Directory containing annotation results, including functional annotation and CDS prediction.  
**$2/hisat2_index/:** Directory containing genome index files for hisat2.  
**$2/<sample>/:** Directories for each sample containing cleaned fastq files and corresponding aligned BAM files.  
**$2/all_counts.tsv:** Gene expression counts for all samples, generated by featureCounts.  


Usage:
```
bash egg_rice_rnaseq_part.sh <input_dir> <output_dir> <reference_file> <annotation_file> 

example:
nohup bash  /your/path/of/scripts/egg_rice_rnaseq_part.sh  /your/path/of/clean_data/  /your/path/of/output/  /your/path/of/ref/all.chrs.con  /your/path/of/ref/eggnog.emapper.decorated.gff.saf &

```

**6.Prepare Genebank files**  
**script.py** converts genome data in FASTA format and gene annotation data in GFF3 format into a GenBank file format.   
**script.py** reads the FASTA file for chromosome sequences and the GFF3 file for gene features (mRNA and CDS), then associates these features with the chromosomes in the GenBank format.  

Purpose:  
To standardize chromosome IDs.  
To parse the GFF3 file for mRNA and CDS annotations.  
To generate a GenBank file containing mRNA and CDS features for each chromosome in the FASTA file.  
It is designed for plant genome data processing but can be used for any genome with appropriate input data.  

Input:  
FASTA file: Contains genome sequence data for multiple chromosomes. The file should have the sequence data in FASTA format with chromosome IDs.  
GFF3 file: Contains annotation data for the genome, including mRNA and CDS features. The file should be in GFF3 format.  

Usage:
```
python script.py <input.fasta> <input.gff3> <output.gbk>

example:
python scripts/create_chr_genbank.py  ./ref/all.chrs.fa  ./ref/all.gff3  ./ref/all.gbk
```

Output:  
The script produces a GenBank file (.gbk), where each chromosome has its corresponding mRNA and CDS features annotated.  
The output file will be saved with the name specified as <output.gbk>.  


**6.Run deepbgc**  
Next, we use DeepBGC to predict biosynthetic gene clusters (BGCs) and use deep learning models to identify BGCs from genomic data. The input is the GenBank format file (all.gbk) generated in the previous step, which contains the genomic data to be used for DeepBGC pipeline operations.  

```
deepbgc pipeline <input.gbk> -o <output_directory> > <log_file> 2>&1

example:
nohup deepbgc pipeline ./ref/all.gbk  -o your/output/path/ > .your/output/log_files/deepbgc.log 2>&1 &

```


## In Rstudio
Before running the pipeline, you need to install and load the following packages：  

```

library(clusterProfiler)    # For functional enrichment analysis  
library(enrichplot)          # For visualization of enrichment results  
library(ggplot2)             # For data visualization  
library(data.table)          # For fast data manipulation  
library(GO.db)               # For Gene Ontology annotations  
library(DESeq2)              # For differential expression analysis  
library(pathview)            # For pathway visualization  
library(GOSemSim)            # For Gene Ontology similarity analysis  
library(AnnotationDbi)       # For database interfacing (annotations)  
library(org.Osativa.eg.db)   # For rice (Oryza sativa) annotations  
library(rtracklayer)         # For working with genomic data (e.g., tracks)  
library(Rsubread)            # For read alignment and counting  
library(pheatmap)            # For heatmap visualizations  
library(RColorBrewer)        # For color palettes  
library(geneplotter)         # For gene expression plots  
library(gplots)              # For additional plotting functionality  
library(jsonlite)            # For working with JSON data  
library(purrr)               # For functional programming (map, reduce, etc.)  
library(RCurl)               # For working with URLs and HTTP requests  
library(stringr)             # For string manipulation  
library(dplyr)               # For data manipulation  
library(DOSE)                # For Disease Ontology Semantic Enrichment  
library(globaltest)          # For global test of differential expression  
library(factoextra)          # For visualizing clustering results  
library(FactoMineR)          # For multivariate data analysis  
library(variancePartition)   # For variance partitioning in DE analysis  
library(EnhancedVolcano)     # For volcano plots of differential expression  
library(tidyr)               # For data tidying  
library(gridExtra)           # For additional grid-based plotting functions  
library(lme4)                # For linear mixed-effects models  
library(Matrix)              # For sparse matrices  
library(colorRamps)          # For color ramp generation  
library(lmerTest)            # For mixed-effects models with p-value calculation  
library(tibble)              # For modern data frames (tibbles)  
library(tidyverse)           # For data manipulation and visualization (includes ggplot2, dplyr, tidyr, etc.)  
library(tidyquant)           # For financial analysis and time series

```

### Required Files
The following files should be exported from the shell and imported into R:  

**all_counts.tsv:**  Raw count data for genes/features, used for differential expression analysis.  
**eggnog.emapper.decorated.gff:**  GFF file with EggNOG orthology mapping and functional annotations.  
**eggnog.emapper.genepred.gff:**  GFF file for gene predictions based on EggNOG mapping.  
**eggnog.emapper.annotations:**  Functional annotations from EggNOG.  
**eggnog.anno:**  Additional EggNOG annotations.  
**geneid_match.tab:**  Gene IDs and corresponding annotations/mappings.  
**all_gbk_2.bgc.tsv:**  Data on biosynthetic gene clusters (BGCs).  



## 1.Data Preparation:  
· Count data is extracted from the input dataset (data), with genes as rows and samples as columns.  
· A metadata table (database) is created to define the experimental conditions (e.g., HT0.5, HT1, LT0.5, etc.).  

## 2.DESeq2 Analysis:  
· A DESeqDataSet object is created from the count data and metadata.  
· Differential expression analysis is performed, with low-count genes filtered out, followed by running DESeq.  

## 3.Principal Component Analysis (PCA):  
· Variance Stabilizing Transformation (VST) is applied to the DESeq2 object, followed by PCA for visualizing the relationship between samples based on gene expression profiles.  

## 4.Pairwise Comparisons:
· Pairwise comparisons between conditions (e.g., HT0.5 vs HT1, HT24 vs LT0.5, etc.) are conducted, and results such as log2 fold change, p-values, and adjusted p-values are stored.

## 5.Normalized Counts:
· Normalized count data is extracted and merged with the differential expression results.

## 6.Output:
· The final results, including normalized counts and differential expression statistics, are saved in a comprehensive data table (resdata).


```
#
countData <- as.matrix(data[, 7: ncol(data)])
rownames(countData) <- data$Geneid


# add group meta 
database <- data.frame(name = colnames(data)[7: ncol(data)], 
                       condition=c(rep(c("HT0.5","HT1","HT24","LT0.5","LT1","LT24"), each = 2)))

row.names(database) <- colnames(data)[7: ncol(data)]

database$condition <- as.factor(database$condition)

## select 
# https://www.biostars.org/p/336298/
dds <- DESeqDataSetFromMatrix(countData, colData=database, design = ~ condition)
dds <- dds[rowSums(counts(dds)) > 1, ]
dds <- DESeq(dds)
res <- as.data.frame(results(dds))


##
# PCA
vsd <- vst(dds, blind=FALSE)
p_pca <- plotPCA(vsd, intgroup=c("condition")) + theme_bw()
# ggsave(paste0(out_dir, "/PCA_all.png"), p_pca, width = 5, height = 5)



###
##
compa_pair <- combn(c("HT0.5","HT1","HT24","LT0.5","LT1","LT24"), 2, simplify = F)
de_sum <- function(dds, cond_pair){
  #
  cond_1 <- cond_pair[1]
  cond_2 <- cond_pair[2]
  
  #
  result_dt <- as.data.frame(results(dds, contrast = c("condition", cond_1, cond_2)))
  
  #
  setDT(result_dt, keep.rownames = "Geneid")
  result_dt <- result_dt[, .(Geneid, log2FoldChange, pvalue, padj)]
  colnames(result_dt) <- paste0(cond_1, "_", cond_2, "_", colnames(result_dt))
  colnames(result_dt)[1] <- "Geneid"
  
  #
  return(result_dt)
}
res <- Reduce(function(x, y) merge(x, y, all=TRUE), lapply(compa_pair, function(x) de_sum(dds, x)))

##
norm_data <- as.data.table(counts(dds, normalized=TRUE), keep.rownames = "Geneid")
colnames(norm_data)[2:ncol(norm_data)] <- paste0("norm_", colnames(norm_data)[2:ncol(norm_data)])


## merge result and normalized counts
resdata <- merge(res, norm_data, all.x = T, by = "Geneid")

```

## 7.Gene Set Enrichment Analysis (GSEA)  and GO Analysis
This part performs Gene Set Enrichment Analysis (GSEA)  and GO Analysis to identify significant biological processes or pathways associated with different experimental conditions. It processes gene expression data (resdata) by filtering differentially expressed genes (DE genes) based on a log2FoldChange threshold and p-value. For each condition pair (e.g., HT0.5 vs. LT0.5), the script dynamically selects the relevant log2FoldChange and p-value columns and uses these to filter DE genes. The analysis is looped over multiple condition pairs (e.g., HT0.5_LT0.5, HT1_LT1), producing enrichment results for each.

Set the condition pairs in the condition_pairs variable and execute the script to perform GSEA and visualize the results. 

```
decorated_gff <- gff_data <- import("yourpath/eggnog.emapper.decorated.gff")

genepred_gff <- gff_data <- import("yourpath/eggnog.emapper.genepred.gff")

## need edit before load !!
emapper_annotations <- fread("yourpath/eggnog.emapper.annotations",  fill=TRUE)


gene2GO <- emapper_annotations[, .(GOs, query)]
gene2Description <- emapper_annotations[, .(GOs, Description)]


### GSEA analysis
# Loop over each condition pair to perform the analysis
# List of condition pairs to analyze
condition_pairs <- list(
  c("HT0.5", "LT0.5"),
  c("HT1", "LT1"),
  c("HT24", "LT24")
)

for (pair in condition_pairs) {
  # Generate the log2FoldChange column name dynamically
  condition_col <- paste0(pair[1], "_", pair[2], "_log2FoldChange")
  
  # Debugging: Print column names in resdata
  print("Available columns in resdata:")
  print(condition_col)
  
  # Prepare GSEA data by selecting Geneid and the dynamic condition column using .SD
  gsea_dt <- resdata[, .SD, .SDcols = c("Geneid", condition_col)]
  
  # Debugging: Check the first few rows of gsea_dt
  print(paste("Checking data for condition:", condition_col))
  print(head(gsea_dt))
  
  # Rank the values in the specified condition column
  gsea_dt[, rank := rank(get(condition_col), ties.method = "random")]
  
  # Order by rank
  gsea_dt <- gsea_dt[order(-rank)]
  
  # Create the ranked list for GSEA
  glist <- gsea_dt$rank
  names(glist) <- gsea_dt$Geneid
  
  # Sort the list in decreasing order
  glist_sorted <- sort(glist, decreasing = TRUE)
  
  # Perform GSEA
  ego <- GSEA(
    gene = glist_sorted, 
    TERM2GENE = gene2GO, 
    TERM2NAME = gene2Description, 
    scoreType = "pos"
  )
  
  # Visualize the results
  enrichplot::dotplot(ego, showCategory = 10, font.size = 14)
}



######
genome_anno = "yourpath/eggnog.anno"
gene_id = "yourpath/geneid_match.tab"

egg <- fread(genome_anno, sep  ="\t")

idmatch <- fread(gene_id, header = F,  col.names = c("query"))
egg <- merge(egg, idmatch, all.x = T)


anno_raw <- merge(egg[, .(query, Preferred_name, Description, COG_category)], 
                  data[, c(1, 7:ncol(data)), with = FALSE],
                  by.x = "query", by.y = "Geneid",
                  all.y = T)
anno_all <- merge(anno_raw, norm_data,
                  by.x = "query", by.y = "Geneid",all.x = T)


## 
# prepare background GO
eggGO <- egg[GOs != '-', .(query, GOs)]
eggGO <- eggGO[, .(GOs = unlist(tstrsplit(GOs, ",", type.convert = TRUE))), by = "query"]
colnames(eggGO) <- c("gene", "go_id")
term_name <- go2term(eggGO$go_id)
ont <- go2ont(eggGO$go_id)
eggGO <- merge(eggGO, ont, by = "go_id")
term_name <- merge(term_name, ont, by = "go_id")

# Loop over each condition pair to perform the analysis
for (pair in condition_pairs) {
  # Generate the log2FoldChange and pvalue column names dynamically
  condition_col <- paste0(pair[1], "_", pair[2], "_log2FoldChange")
  condition_col_pvalue <- paste0(pair[1], "_", pair[2], "_pvalue")
  
  # Ensure the relevant columns are numeric
  resdata[[condition_col]] <- as.numeric(resdata[[condition_col]])
  resdata[[condition_col_pvalue]] <- as.numeric(resdata[[condition_col_pvalue]])
  
  # Filter DE genes based on log2FoldChange and p-value
  resdata_DE <- resdata[abs(resdata[[condition_col]]) >= 1 & resdata[[condition_col_pvalue]] <= 0.05]
  
  # Debugging: Check if there are any DE genes
  print(paste("Number of DE genes for", condition_col, ":", nrow(resdata_DE)))
  
  if (nrow(resdata_DE) == 0) {
    next  # Skip if no DE genes for the current condition pair
  }
  
  # Perform GSEA
  ego <- enricher(
    gene = resdata_DE$Geneid, 
    TERM2GENE = eggGO[, .(go_id, gene)], 
    TERM2NAME = term_name
  )
  
  # Convert result to data.table and plot
  ego_dt <- as.data.table(ego)
  barplot(ego)
  
  # Dotplot visualization
  enrichplot::dotplot(ego, showCategory = 10, font.size = 14)
  
  # Pairwise term similarity for enrichment result
  ego <- pairwise_termsim(ego)
  
  # EMAP plot
  emapplot(ego, showCategory = 10)
}

```


## 7.Gene Set Enrichment Analysis (GSEA)  and GO Analysis
This part performs Gene Set Enrichment Analysis (GSEA)  and GO Analysis to identify significant biological processes or pathways associated with different experimental conditions. It processes gene expression data (resdata) by filtering differentially expressed genes (DE genes) based on a log2FoldChange threshold and p-value. For each condition pair (e.g., HT0.5 vs. LT0.5), the script dynamically selects the relevant log2FoldChange and p-value columns and uses these to filter DE genes. The analysis is looped over multiple condition pairs (e.g., HT0.5_LT0.5, HT1_LT1), producing enrichment results for each.

Set the condition pairs in the condition_pairs variable and execute the script to perform GSEA and visualize the results. 

```
# Get all BGC IDs
BGC_ids <- unique(gene_in_BGC_expr_filtered$BGC_id)

# Create a new data table to save the results
result_table <- data.table(BGC_id = character(),
                           Gene = character(),
                           p_value = numeric(),
                           significance = character())


# Loop through each BGC_id
for (BGC_id_in in BGC_ids) {
  
  print(paste("Processing BGC_id:", BGC_id_in))
  
  # Extract data corresponding to the current BGC_id
  X <- t(gene_in_BGC_expr_filtered[BGC_id == BGC_id_in, 
                                   .(`norm_HT0.5-2`, `norm_HT0.5-3`, `norm_HT1-3`, `norm_HT1-4`, `norm_HT24-2`, `norm_HT24-3`,
                                     `norm_LT0.5-2`, `norm_LT0.5-3`, `norm_LT1-3`, `norm_LT1-4`, `norm_LT24-2`, `norm_LT24-4`)])
  
  # Set the column names of X to be the gene IDs corresponding to the current BGC_id
  colnames(X) <- gene_in_BGC_expr_filtered[BGC_id == BGC_id_in, Geneid]
  
  # Loop through each column of X and perform the GlobalTest
  for (gene_index in 1:ncol(X)) {
    
    # Expression data for the current gene
    Y <- X[, gene_index, drop = FALSE]  # Use drop=FALSE to retain the data frame structure
    
    # Set Y as the response variable, and the other columns of X as covariates
    X_others <- X[, -gene_index, drop = FALSE]  # Select columns other than the current gene as covariates
    
    # Get the current gene's name
    gene_name <- colnames(X)[gene_index]
    
    # Print debug information to check X and Y
    print(paste("Running globaltest for BGC_id:", BGC_id_in, "Gene:", gene_name))
    
    # Run globaltest (assumes X_others are covariates and Y is the response variable)
    result <- gt(Y, X_others)
    
    # Extract p-value
    p_value <- p.value(result)
    
    # Print the current p-value to check if it's valid
    print(paste("p_value for", gene_name, ":", p_value))
    
    # Save the result, adding BGC_id, gene name, and p-value
    if (!is.na(p_value) && p_value < 0.05) {
      significance <- "significant"
    } else {
      significance <- "ns"  # "ns" for non-significant
    }
    
    result_table <- rbind(result_table, 
                          data.table(BGC_id = BGC_id_in, 
                                     Gene = gene_name, 
                                     p_value = p_value, 
                                     significance = significance))
  }
  
  print(paste0("End processing BGC_id:", BGC_id_in))
}

# Print the final result table
print(result_table)

# Get the unique BGC_ids with significant results
unique(result_table[significance == "significant", BGC_id])

```





```
library(GENIE3)

BGC_ids <- unique(gene_in_BGC_expr_filtered$BGC_id)

# Initialize a list to store the linkList_filtered for each BGC_id
all_linkLists <- list()

# Function to plot the correlation heatmap for each BGC_id
plot_regulatory_heatmap <- function(BGC_id_in) {
  
  # Get the regulatory links for the selected BGC_id
  linkList_filtered <- all_linkLists[[BGC_id_in]]
  
  # Ensure the filtered links are not empty and have at least two rows
  if (nrow(linkList_filtered) < 2) {
    print(paste("Not enough regulatory links for BGC_id:", BGC_id_in))
    return(NULL)
  }
  
  # Create a correlation matrix based on the regulatory links
  link_matrix <- as.data.table(linkList_filtered)[, .(regulatoryGene, targetGene, weight)]
  
  # Reshape the data into a wide format matrix
  link_matrix_wide <- dcast(link_matrix, regulatoryGene ~ targetGene, value.var = "weight", fill = 0)
  
  
  rownames <- link_matrix_wide$regulatoryGene  # Assign rownames before dropping the column
  link_matrix_wide <- link_matrix_wide[, -1]
  link_matrix_wide <- as.data.frame(link_matrix_wide)
  rownames(link_matrix_wide) <- rownames
  
  # Print to verify the output
  print("Final link_matrix_wide:")
  print(link_matrix_wide)
  rownames(link_matrix_wide)
  
  # Plot heatmap
  pheatmap(as.matrix(link_matrix_wide), 
           cluster_rows = FALSE, 
           cluster_cols = FALSE,
           display_numbers = TRUE, 
           show_rownames = TRUE,  # Ensure row names are displayed
           show_colnames = TRUE, 
           angle_col = 45,  # Rotate column names by 45 degrees
           fontsize = 14,  # Increase overall font size
           fontsize_row = 14,  # Increase row name font size
           fontsize_col = 14,  # Increase column name font size
           main = paste("Regulatory Network Heatmap for", BGC_id_in))
}


# Loop through each BGC_id for analysis
for (BGC_id_in in BGC_ids) {
  
  print(paste("Processing BGC_id:", BGC_id_in))
  
  # Extract the gene expression matrix for the current BGC_id
  exprMatrix <- as.matrix(gene_in_BGC_expr_filtered[BGC_id == BGC_id_in, 
                                                    .(`norm_HT0.5-2`, `norm_HT0.5-3`, `norm_HT1-3`, `norm_HT1-4`, `norm_HT24-2`, `norm_HT24-3`,
                                                      `norm_LT0.5-2`, `norm_LT0.5-3`, `norm_LT1-3`, `norm_LT1-4`, `norm_LT24-2`, `norm_LT24-4`)])
  
  # Set row names to be gene IDs
  rownames(exprMatrix) <- gene_in_BGC_expr_filtered[BGC_id == BGC_id_in, Geneid]
  
  # Ensure that the expression matrix is correct
  if (nrow(exprMatrix) == 0 || ncol(exprMatrix) == 0) {
    print(paste("Empty expression matrix for BGC_id:", BGC_id_in))
    next  # Skip if the matrix is empty
  }
  
  # Set the seed to ensure reproducibility
  set.seed(123)  
  
  # Get the number of genes
  num_genes <- nrow(exprMatrix)
  
  # Ensure there are at least two genes to be used as regulators
  if (num_genes < 2) {
    print(paste("Not enough genes for BGC_id:", BGC_id_in))
    next  # Skip this BGC_id if there are not enough genes
  }
  
  # Use all genes as regulators
  regulators <- rownames(exprMatrix)  
  
  # Run GENIE3 to infer the gene regulatory network
  weightMatrix <- GENIE3(exprMatrix, regulators = regulators)
  
  # Extract regulatory links using getLinkList
  linkList_filtered <- getLinkList(weightMatrix, threshold = 0.5)
  
  # Add the filtered linkList for each BGC_id to all_linkLists
  all_linkLists[[BGC_id_in]] <- linkList_filtered
  
  # Check if there are enough regulatory links
  if (nrow(linkList_filtered) < 2) {
    print(paste("Skipping BGC_id:", BGC_id_in, "due to insufficient regulatory links"))
    next  # Skip if there are too few regulatory links
  }
  
  # Print end message for current BGC_id
  print(paste("BGC_id:", BGC_id_in, "down"))
  
  # Plot the regulatory heatmap for the current BGC_id
  plot_regulatory_heatmap(BGC_id_in)
}

# Print all regulatory links for all BGC_ids
print(all_linkLists)


```



